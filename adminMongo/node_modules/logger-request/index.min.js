"use strict";

function __info(my) {
    var promise = Array.call();
    if (my.pid && promise.push([ "pid", function() {
        return process.pid;
    } ]), my.bytesReq && promise.push([ "bytesReq", function(req) {
        return req.socket.bytesRead;
    } ]), my.bytesRes && promise.push([ "bytesRes", function(req) {
        return req.socket._bytesDispatched;
    } ]), my.referer && promise.push([ "referer", function(req) {
        return req.headers.referer || req.headers.referrer;
    } ]), my.auth) {
        var mod0 = require("basic-authentication")({
            legacy: !0
        });
        promise.push([ "auth", function(req) {
            return mod0(req).user;
        } ]);
    }
    if (my.transfer) {
        var mod1 = require("transfer-rate")();
        promise.push([ "transfer", function(req) {
            return mod1(req, req.start);
        } ]);
    }
    my.agent && promise.push([ "agent", function(req) {
        return req.headers["user-agent"];
    } ]), my.lang && promise.push([ "lang", function(req) {
        return req.headers["accept-language"];
    } ]), my.cookie && promise.push([ "cookie", function(req) {
        return req.cookies;
    } ]), my.headers && promise.push([ "headers", function(req) {
        return req.headers;
    } ]), my.version && promise.push([ "version", function(req) {
        return req.httpVersionMajor + "." + req.httpVersionMinor;
    } ]), my.callback && promise.push([ "callback", function(req) {
        return my.callback(req);
    } ]);
    var l = promise.length;
    return 0 === l ? function(req, statusCode, end) {
        var diff = 1e3 * end[0] + 1e-6 * end[1];
        return {
            ip: req.remoteAddr || req.ip,
            method: req.method,
            status: statusCode,
            url: req.url,
            response: diff.toFixed(2)
        };
    } : function(req, statusCode, end) {
        for (var diff = 1e3 * end[0] + 1e-6 * end[1], out = {
            ip: req.remoteAddr || req.ip,
            method: req.method,
            status: statusCode,
            url: req.url,
            response: diff.toFixed(2)
        }, i = 0; i < l; ++i) {
            var p = promise[i];
            out[p[0]] = p[1](req);
        }
        return out;
    };
}

function wrapper(log, my, io) {
    function finale(req, statusCode, start) {
        return req.start = start, log(my.logger, io(req, statusCode, process.hrtime(start)));
    }
    var finished = require("on-finished");
    return my.deprecated ? require("util").deprecate(function(req, res, next) {
        var start = process.hrtime();
        if (req.remoteAddr = req.ip, res._headerSent) finale(req, res.statusCode, start); else {
            var buffer = res.end;
            res.end = function(chunk, encoding) {
                res.end = buffer;
                var b = res.end(chunk, encoding);
                return finale(req, res.statusCode, start), b;
            };
        }
        return next ? next() : null;
    }, "`logger-request` option is deprecated") : my.functions ? function(req, res) {
        return req.remoteAddr = req.ip, finale(req, res.statusCode, process.hrtime());
    } : function(req, res, next) {
        var start;
        return req.remoteAddr = req.ip, finished(res, function() {
            return finale(req, res.statusCode, start);
        }), start = process.hrtime(), next();
    };
}

function logger(opt) {
    var winston = require("winston"), options = opt || Object.create(null), my = {
        filename: options.filename || !1,
        daily: Boolean(options.daily),
        transports: Array.isArray(options.transports) ? options.transports : []
    };
    Boolean(options.deprecated) ? my.deprecated = !0 : Boolean(options.functions) && (my.functions = !0);
    var optional = options.winston || Object.create(null);
    optional.logger = String(optional.logger || "logger-request"), optional.level = String(optional.level || "info"), 
    optional.timestamp = optional.timestamp || !0, optional.maxsize = Number(optional.maxsize) || 8388608, 
    optional.maxFiles = Number(optional.maxFiles) || null, optional.json = optional.json !== !1, 
    optional.raw = optional.raw !== !1, my.logger = optional.logger;
    var log = new winston.Logger();
    my.filename && (optional.filename = require("path").resolve(String(my.filename)), 
    my.daily ? (optional.prepend = !0, log.add(require("winston-daily-rotate-file"), optional)) : log.add(winston.transports.File, optional)), 
    Boolean(options.console) && log.add(winston.transports.Console, optional);
    for (var i = 0, ii = my.transports.length; i < ii; ++i) log.add(my.transports[i], optional);
    return log = log[optional.level], Boolean(options.standalone) ? log : (options = options.custom || Object.create(null), 
    wrapper(log, my, __info({
        pid: Boolean(options.pid),
        bytesReq: Boolean(options.bytesReq),
        bytesRes: Boolean(options.bytesRes),
        referer: Boolean(options.referer),
        auth: Boolean(options.auth),
        transfer: Boolean(options.transfer),
        agent: Boolean(options.agent),
        lang: Boolean(options.lang),
        cookie: Boolean(options.cookie),
        headers: Boolean(options.headers),
        version: Boolean(options.version),
        callback: "function" == typeof options.callback && options.callback
    })));
}

module.exports = logger;
